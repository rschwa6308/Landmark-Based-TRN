# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PathAnimation
                                 A QGIS plugin
 This plugin creates timestamped vector layers showing the observations made
 by a robot traveling along a given path, which can then be used to render
 animations.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-10
        copyright            : (C) 2021 by NASA JPL
        email                : russells@jpl.nasa.gov
 ***************************************************************************/
"""

__author__ = "NASA JPL"
__date__ = "2021-03-10"
__copyright__ = "(C) 2021 by NASA JPL"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

from qgis.PyQt.QtCore import QCoreApplication, QVariant, QDateTime
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterDateTime,
                       QgsFields,
                       QgsWkbTypes,
                       QgsField,
                       QgsFeature,
                       QgsGeometry,
                       QgsExpression,
                       QgsExpressionContext,
                       NULL)


import processing

from osgeo import gdal
from affine import Affine

import numpy as np
from math import atan2, degrees


class PathAnimationAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    PATH = "PATH"
    LANDMARKS = "LANDMARKS"
    FIMS = "FIMS"
    POINTING_ACCURACY = "POINTING_ACCURACY"
    NUM_SDS = "NUM_SDS"
    START_TIME = "START_TIME"
    SECONDS_PER_WAYPOINT = "SECONDS_PER_WAYPOINT"
    ROBOT_SPEED = "ROBOT_SPEED"

    WAYPOINTS = "WAYPOINTS"
    OBSERVATION_RAYS = "OBSERVATION_RAYS"
    COVARIANCE_ELLIPSES = "COVARIANCE_ELLIPSES"

    START_TIME = "START_TIME"

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # TODO: add dropdown for selecting which estimator quality metric to use

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PATH,
                self.tr("Robot Path"),
                [QgsProcessing.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LANDMARKS,
                self.tr("Landmarks"),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.FIMS,
                self.tr("FIM Rasters"),
                QgsProcessing.TypeRaster
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.POINTING_ACCURACY,
                self.tr("Pointing accuracy, milliradians"),
                QgsProcessingParameterNumber.Double,
                defaultValue=1.75
            ),
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.NUM_SDS,
                self.tr("Number of SD's for ellipses"),
                QgsProcessingParameterNumber.Double,
                defaultValue=40.0
            ),
        )

        self.addParameter(
            QgsProcessingParameterDateTime(
                self.START_TIME,
                self.tr("Timestamp of first waypoint"),
                defaultValue=QDateTime.fromSecsSinceEpoch(0)
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.SECONDS_PER_WAYPOINT,
                self.tr("Travel time between waypoints, seconds"),
                QgsProcessingParameterNumber.Double,
                defaultValue=1.0
            ),
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.ROBOT_SPEED,
                self.tr("Robot speed, m/s"),
                QgsProcessingParameterNumber.Double,
                defaultValue=1.0
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.WAYPOINTS,
                self.tr("Waypoints"),
                QgsProcessing.TypeVectorPoint
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OBSERVATION_RAYS,
                self.tr("Observation Rays"),
                QgsProcessing.TypeVectorLine
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.COVARIANCE_ELLIPSES,
                self.tr("Covariance Ellipses"),
                QgsProcessing.TypeVectorPolygon
            )
        )


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # load all the layers
        path_layer = self.parameterAsSource(parameters, self.PATH, context)

        landmarks_layer = self.parameterAsSource(parameters, self.LANDMARKS, context)
        landmarks = list(landmarks_layer.getFeatures())
        feedback.pushDebugInfo(f"Landmarks: {landmarks}")

        fim_layers = self.parameterAsLayerList(parameters, self.FIMS, context)
        fim_layers.sort(key=lambda l: int(l.name()[:-4].split("_")[-1]))        # TODO: make this more robust
        feedback.pushDebugInfo("FIM layers: " + ", ".join(layer.name() for layer in fim_layers))

        pointing = self.parameterAsDouble(parameters, self.POINTING_ACCURACY, context) * 1e-3   # convert to radians
        num_sds = self.parameterAsDouble(parameters, self.NUM_SDS, context)

        start_time = self.parameterAsDateTime(parameters, self.START_TIME, context)
        seconds_per_waypoint = self.parameterAsDouble(parameters, self.SECONDS_PER_WAYPOINT, context)
        robot_speed = self.parameterAsDouble(parameters, self.ROBOT_SPEED, context)


        # instantiate output sinks
        waypoints_fields = QgsFields()
        waypoints_fields.append(QgsField("timestamp", QVariant.DateTime))
        waypoints_sink, waypoints_dest_id = self.parameterAsSink(
            parameters,
            self.WAYPOINTS,
            context,
            waypoints_fields,
            QgsWkbTypes.Point,
            path_layer.sourceCrs()     # same as input layer
        )

        rays_fields = QgsFields()
        rays_fields.append(QgsField("timestamp", QVariant.DateTime))
        rays_fields.append(QgsField("info_gain", QVariant.Double))
        rays_sink, rays_dest_id = self.parameterAsSink(
            parameters,
            self.OBSERVATION_RAYS,
            context,
            rays_fields,
            QgsWkbTypes.LineString,
            path_layer.sourceCrs()     # same as input layer
        )

        ellipses_fields = QgsFields()
        ellipses_fields.append(QgsField("timestamp", QVariant.DateTime))
        # ellipses_fields.append(QgsField("center", QVariant.PointXY))
        ellipses_sink, ellipses_dest_id = self.parameterAsSink(
            parameters,
            self.COVARIANCE_ELLIPSES,
            context,
            ellipses_fields,
            QgsWkbTypes.Polygon,
            path_layer.sourceCrs()     # same as input layer
        )


        # split path into waypoints
        distance_between_waypoints = robot_speed * seconds_per_waypoint
        waypoints_layer_name = processing.run(
            "native:pointsalonglines",
            {
                'INPUT': parameters[self.PATH],
                'DISTANCE': distance_between_waypoints,
                'END_OFFSET': 0,
                'START_OFFSET': 0,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            },
            is_child_algorithm=True,
            context=context,
            feedback=feedback
        )["OUTPUT"]
        waypoints_layer = context.takeResultLayer(waypoints_layer_name)


        # assosciate timestamps with waypoints and add to output sink
        waypoints = []
        for i, waypoint in enumerate(waypoints_layer.getFeatures()):
            timestamp = start_time.addSecs(seconds_per_waypoint * i)
            waypoint_copy = QgsFeature(waypoint)
            waypoint_copy.setFields(waypoints_fields)
            waypoint_copy.setAttribute("timestamp", timestamp)
            waypoints_sink.addFeature(waypoint_copy)
            waypoints.append(waypoint_copy)


        # compute observation rays and covariance ellipses and add them to their respective sinks
        expr_context = QgsExpressionContext()
        for waypoint in waypoints:
            feedback.pushDebugInfo(f"waypoint: {waypoint.attributes()} @ {waypoint.geometry()}")
            if feedback.isCanceled(): return {}

            timestamp = waypoint.attribute("timestamp")
            waypoint_point = waypoint.geometry().asPoint()

            total_fim = np.array([0.0, 0.0, 0.0])

            # create observation rays
            for landmark, fim_layer in zip(landmarks, fim_layers):
                fim_result = [fim_layer.dataProvider().sample(waypoint_point, i)[0] for i in range(1, 4)]
                # feedback.pushDebugInfo(f"fim_result: {fim_result}")

                total_fim += np.array(fim_result)

                if fim_result != [0.0, 0.0, 0.0]:   # landmark is visible
                    # create a new feature
                    seg = QgsFeature()
                    line_start = waypoint_point
                    line_end = landmark.geometry().asPoint()
                    seg.setGeometry(QgsGeometry.fromPolylineXY([line_start, line_end]))
                    seg.setFields(rays_fields)
                    seg.setAttribute("timestamp", timestamp)
                    rays_sink.addFeature(seg)
            
            total_fim /= pointing ** 2

            # create covariance ellipses
            fim_mat = np.array([
                [total_fim[0], total_fim[1]],
                [total_fim[1], total_fim[2]]
            ])

            try:
                cov_mat = np.linalg.inv(fim_mat)    # TODO: handle singular matrix exception
            except np.linalg.LinAlgError:
                feedback.pushDebugInfo(f"singular FIM encountered at {waypoint_point}")
                continue
        
            ellipse = QgsFeature()

            # https://cookierobotics.com/007/
            try:
                eigs, _ = np.linalg.eig(cov_mat)
                l1, l2 = sorted(eigs, reverse=True)
                if l1 > 1_000_000:
                    feedback.pushDebugInfo(f"GDOP: infty")
                    continue     # don't draw stupudly huge ellipses
                # if l1 < l2: l1, l2 = l2, l1
                feedback.pushDebugInfo(f"GDOP: {l1 ** 0.5 + l2 ** 0.5}")
                major = (l1 ** 0.5) * num_sds
                minor = (l2 ** 0.5) * num_sds
                theta = degrees(atan2(l1 - cov_mat[0,0], cov_mat[0,1])) + 90     # TODO: make sure this is right
                feedback.pushDebugInfo(f"{major}, {minor}, {theta}")
                ellipse_expr = QgsExpression(f"make_ellipse(make_point({waypoint_point.x()},{waypoint_point.y()}), {major}, {minor}, {theta})")
                ellipse.setGeometry(ellipse_expr.evaluate(expr_context))
                ellipse.setFields(ellipses_fields)
                ellipse.setAttribute("timestamp", timestamp)
                ellipses_sink.addFeature(ellipse)
            except np.linalg.LinAlgError:
                feedback.pushDebugInfo(f"GDOP: infty")
                continue



        return {
            self.WAYPOINTS: waypoints_dest_id,
            self.OBSERVATION_RAYS: rays_dest_id,
            self.COVARIANCE_ELLIPSES: ellipses_dest_id
        }

    
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return "Animate Path"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ""

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PathAnimationAlgorithm()
